# 语言并发

## 并发&并行

并发有多种：
- 并发：程序在一个核心进行
- 并行：利用多核

golang具有高并发性能
- golang可以利用协程

协程是什么？
- 我们知道，在计算机系统中有进程和线程，前者是程序，后者是程序中的最小控制流
- 而协程是一种比线程更加轻量的线程，可以看作一个可以将进度保存在栈中，随时继续的线程，不需要改变内核状态（而线程需要）。因此协程十分轻量化

## goroutine & channel

如何使用golang协程
- 在调用函数前，标志 `go`

如何协程之间通信
- 通信而共享内存，而非共享内存实现通信(也支持这种，但不建议，容易产生并发安全问题)
- 使用通道，一种结构体，`chan`

channel 的声明
```go
make(chan int)
//无缓冲，又称为同步通道
make(chan int, bufsize)
//后者为缓冲通道，具有缓冲大小
```

channel 的使用
- 使用 `range` 循环获得直至通道关闭
- 使用 `channel <- val` 传递值

## sync

如何实现共享内存的协程？
- `sync.Mutex`

如何控制协程的结束与开始？
- `sync.WaitGroup` 三个方法
	- Add(delta int)
	- Done()
	- Wait()
- 在开始协程时 `wg.Add()` 设置协程个数，在协程函数中 `defer sync.WaitGroup.Done()` ，在并发流程结束后 `wg.Wait()`

# 依赖管理

依赖就是各种开发包

## 依赖管理演变

GOPATH     Go Vender     Go Module

### GOPATH

即环境变量 `GOPATH` ，项目代码直接依赖 src 下的代码

问题
- 如果两个项目依赖于不同版本的代码？
- 不能实现多版本控制

### Go Vender

项目目录下面添加 `vender` 文件，借此寻找 `GOPATH`

问题
- 无法控制依赖版本
- 同样存在冲突

### Go Mod

依赖管理三要素
- 配置文件，描述管理     go.mod
- 中心仓库管理依赖库     Proxy
- 本地工具     go get/mod

# 测试

## 单元测试

### 三种测试方法

- 回归测试
- 集成测试
- 单元测试
从上到下覆盖率增大，成本下降

什么是单元测试
- 将函数，模块设置为测试单元，依次使用输入测试是否正确

单元测试规则
- 所有测试文件以 `_test.go` 结尾
- `func TestXxx(*testing.T)`
- 初始化以及结尾资源释放在函数 `TestMain` 中执行

单元测试运行
- `go test [flags][pkgs]`

进行单元测试
- `assert`

评估测试强度
- **覆盖率**
- `go test judge_test.go judge.go --cover`
- 会显示测试覆盖语句数占总语句数的比例
- 一般50~60，较好80%
- 测试分支应该相互独立
- 测试单元粒度应该足够小，函数单一职责（便于寻找错误

## mock测试




## 基准测试

用于对代码进行性能分析，使用方法类似于单元测试




